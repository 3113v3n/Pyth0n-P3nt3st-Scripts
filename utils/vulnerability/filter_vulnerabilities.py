class FilterVulnerabilities:
    """Filters vulnerabilities depending on scanner used"""

    def __init__(self):
        self.scanner = None

    def update_scanner(self, scanner):
        self.scanner = scanner

    def filter_vulnerabilities(self, vulnerabilities, regex_word, filter_param):
        """TODO: Filter vulnerabilities depending on the scanner used"""
        
        match filter_param:
            case "ssl_condition":
                if self.scanner == "nessus":
                    return {
                        "ssl_condition": (vulnerabilities["Name"].notna())
                        & (
                            vulnerabilities["Name"].str.contains(
                                regex_word("SSL"), regex=True
                            )
                        )
                        | (
                            vulnerabilities["Name"].str.contains(
                                regex_word("TLS"), regex=True
                            )
                        )
                        | (
                            vulnerabilities["Name"].str.contains(
                                regex_word("POODLE"), regex=True
                            )
                        )
                    }
                elif self.scanner == "rapid":
                    return {
                        "ssl_condition": (vulnerabilities["Vulnerability Title"].notna())
                        & (
                            vulnerabilities["Vulnerability Title"].str.contains(
                                self.regex_word("SSL"), regex=True
                            )
                        )
                        | (
                            vulnerabilities["Vulnerability Title"].str.contains(
                                self.regex_word("TLS"), regex=True
                            )
                        )
                    }
            case "missing_patch_condition":
                return {
                    "missing_patch_condition": (vulnerabilities["Solution"].notna())
                    & (
                        vulnerabilities["Solution"].str.contains(
                            regex_word("Update"), regex=True
                        )
                    )
                    | (vulnerabilities["Solution"].str.contains(regex_word("patches")))
                    | (vulnerabilities["Solution"].str.contains(regex_word("updates")))
                    | (
                        vulnerabilities["Solution"].str.contains(
                            regex_word("security update")
                        )
                    )
                    | (
                        vulnerabilities["Solution"].str.contains(
                            regex_word("Microsoft has released")
                        )
                    ),
                }
            case "unsupported_software":
                return {
                    "unsupported_software": (vulnerabilities["Solution"].notna())
                    & (
                        vulnerabilities["Solution"].str.contains(
                            regex_word("Upgrade", is_extra=True,
                                       second_term="Update"),
                            regex=True,
                        )
                    )
                    | (
                        vulnerabilities["Name"].str.contains(
                            regex_word("no longer supported"), regex=True
                        )
                    )
                    | (
                        vulnerabilities["Description"].str.contains(
                            regex_word("no longer supported"), regex=True
                        )
                    )
                    | (
                        vulnerabilities["Name"].str.contains(
                            regex_word("unsupported"), regex=True
                        )
                    )
                    | (
                        vulnerabilities["Solution"].str.contains(
                            regex_word("unsupported"), regex=True
                        )
                    )
                    | (
                        vulnerabilities["Solution"].str.contains(
                            regex_word("Unsupported Version"), regex=True
                        )
                    )
                    | (
                        vulnerabilities["Name"].str.contains(
                            regex_word("Unsupported Version"), regex=True
                        )
                    ),
                }
            case "kaspersky_condition":
                return {
                    "kaspersky_condition": (vulnerabilities["Name"].notna())
                    & vulnerabilities["Name"].str.contains(
                        regex_word("Kaspersky"), regex=True
                    ),
                }
            case "insecure_condition":
                return {
                    "insecure_condition": (vulnerabilities["Name"].notna())
                    & vulnerabilities["Name"].str.contains(
                        regex_word("Insecure Windows Service"), regex=True
                    ),
                }
            case "winverify_condition":
                return {
                    "winverify_condition": (vulnerabilities["Name"].notna())
                    & vulnerabilities["Name"].str.contains(
                        regex_word("WinVerifyTrust"), regex=True
                    ),
                }
            case "unquoted_condition":
                return {
                    "unquoted_condition": (vulnerabilities["Name"].notna())
                    & vulnerabilities["Name"].str.contains(
                        regex_word("Unquoted Service Path"), regex=True
                    ),
                }
            case "smb_condition":
                return {
                    "smb_condition": (vulnerabilities["Name"].notna())
                    & vulnerabilities["Name"].str.contains(
                        regex_word("SMB"), regex=True
                    ),
                }
            case "speculative_condition":
                return {
                    "speculative_condition": (vulnerabilities["Name"].notna())
                    & vulnerabilities["Name"].str.contains(
                        regex_word("Windows Speculative"), regex=True
                    ),
                }
            case "AD_condition":
                return {
                    "AD_condition": (vulnerabilities["Name"].notna())
                    & vulnerabilities["Name"].str.contains(
                        regex_word("AD Starter"), regex=True
                    ),
                }
            case "defender_condition":
                return {
                    "defender_condition": (vulnerabilities["Synopsis"].notna())
                    & vulnerabilities["Synopsis"].str.contains(
                        regex_word("antimalware"), regex=True
                    ),
                }
            case "rdp_condition":
                return {
                    "rdp_condition": (vulnerabilities["Name"].notna())
                    & (
                        vulnerabilities["Name"].str.contains(
                            regex_word("Terminal Services"), regex=True
                        )
                    )
                    | (
                        vulnerabilities["Name"].str.contains(
                            regex_word("Remote Desktop Protocol"), regex=True
                        )
                    ),
                }
            case "compliance_condition":
                return {
                    "compliance_condition": (vulnerabilities["Risk"].notna())
                    & (
                        vulnerabilities["Risk"].str.contains(
                            regex_word("FAILED"), regex=True
                        )
                    )
                    & (
                        vulnerabilities["Synopsis"].str.contains(
                            regex_word("Compliance checks"), regex=True
                        )
                    ),
                }
            case "ssh_condition":
                return {
                    "ssh_condition": (vulnerabilities["Synopsis"].notna())
                    & vulnerabilities["Synopsis"].str.contains(
                        regex_word("SSH server"), regex=True
                    ),
                }
            case "telnet_condition":
                return {
                    "telnet_condition": (vulnerabilities["Name"].notna())
                    & vulnerabilities["Name"].str.contains(
                        regex_word("Telnet Server"), regex=True
                    ),
                }
            case "information_condition":
                return {
                    "information_condition": (vulnerabilities["Name"].notna())
                    & vulnerabilities["Name"].str.contains(
                        regex_word("Information Disclosure"), regex=True
                    ),
                }
            case "web_condition":
                return {
                    "web_condition": (vulnerabilities["Name"].notna())
                    & (
                        vulnerabilities["Name"].str.contains(
                            regex_word("Web"), regex=True
                        )
                    )
                    | (
                        vulnerabilities["Description"].str.contains(
                            regex_word("web server"), regex=True
                        )
                    ),
                }
            case "rce_condition":
                return {
                    "rce_condition": (vulnerabilities["Description"].notna())
                    & (
                        vulnerabilities["Description"].str.contains(
                            regex_word("remote code execution"), regex=True
                        )
                    ),
                }
            case _:
                pass

    @staticmethod
    def loop_through_files(file_list: list,
                           start_file,
                           read_csv: callable,  # reference a callable function
                           original_datafile,
                           error_text: str,
                           get_missing_columns: callable,
                           concat_dataframes: callable
                           ):
        all_vulnerabilities = original_datafile
        for file in file_list:
            if file["full_path"] != start_file:
                # Read CSV file without headers
                new_data = read_csv(file["full_path"], header=None)

                # Check if new data is empty
                if new_data.empty:
                    print(f"Skipping empty file : {file['filename']}")
                    continue

                # Ensure columns match
                if original_datafile.shape[1] != new_data.shape[1]:
                    print(
                        f"New file {file['filename']} has {
                            len(new_data.columns)} columns "
                    )
                    raise ValueError(error_text)

                # Check if other files have missing columns
                get_missing_columns(new_data, file["filename"])
                # Append new data to the original data
                all_vulnerabilities = concat_dataframes(
                    all_vulnerabilities, new_data
                )
        return all_vulnerabilities

    @staticmethod
    def percentage_null_fields(dataframe):
        # determine percentage accuracy of the data by showing null fields
        for i in dataframe.columns:
            null_rate = dataframe[i].isna().sum() / len(dataframe) * 100
            if null_rate > 0:
                print(f"{i} null rate: {null_rate:.2f}%")

    @staticmethod
    def csv_filter_operations(dataframe, filter_option, operation, **kwargs):
        # Function to combine all the major CSV filters into one for code clarity
        match operation:
            case "notnull":
                return dataframe[filter_option].notna()
            case "contains":
                if "contains_key" in kwargs:
                    # check for any key value pair passed as an  extra argument and uses it as a filter
                    return dataframe[filter_option].str.contains(kwargs["contains_key"])
            case "in":
                if "in_key" in kwargs:
                    return dataframe[filter_option].isin(kwargs["in_key"])
            case _:
                raise ValueError(f"Invalid filter option: {filter_option}")

    @staticmethod
    def regex_word(search_term, **kwargs):
        if "is_extra" in kwargs:
            return rf'\b{search_term}\b(?!.*\b{kwargs["second_term"]}\b)'
        return rf"\b{search_term}\b"
