# trunk-ignore-all(black)

from ..shared import VAConfigs, CustomDecorators
import re


class FilterVulnerabilities(VAConfigs, CustomDecorators):
    """Filters vulnerabilities depending on scanner used"""

    def __init__(self):
        super().__init__()
        self.scanner = None

        # self.filter_vulnerabilities = self.decorators.measure_execution_time(
        #     self.filter_vulnerabilities)

    SCANNERS = ["nessus", "rapid"]

    def update_scanner(self, scanner):
        self.scanner = scanner

    @property
    def reset_timer(self):
        """Reset the timer"""
        self.timer.reset_total_time()

    @staticmethod
    def percentage_null_fields(dataframe):
        # determine percentage accuracy of the data by showing null fields
        for i in dataframe.columns:
            null_rate = dataframe[i].isna().sum() / len(dataframe) * 100
            if null_rate > 0:
                print(f"{i} null rate: {null_rate:.2f}%")

    @staticmethod
    def csv_filter_operations(dataframe, filter_option, operation, **kwargs):
        # Function to combine all the major CSV filters into one for code clarity
        match operation:
            case "notnull":
                return dataframe[filter_option].notna()
            case "contains":
                if "contains_key" in kwargs:
                    # check for any key value pair passed as an extra argument and uses it as a filter
                    return dataframe[filter_option].str.contains(kwargs["contains_key"])
            case "in":
                if "in_key" in kwargs:
                    return dataframe[filter_option].isin(kwargs["in_key"])
            case _:
                raise ValueError(f"Invalid filter option: {filter_option}")

    @staticmethod
    def regex_word(search_term: str, **kwargs):
        """Performs a regex check against a given term
        :param  search_term: string containing the characters to search for
        :param  kwargs:
        Return str
                checks for text that has the first term but not the second

        Return bool
        """
        if kwargs.get("second_term"):
            return rf'\b{search_term}\b(?!.*\b{kwargs["second_term"]}\b)'
        return rf"\b{search_term}\b"

    @CustomDecorators.measure_execution_time
    def filter_vulnerabilities(self, vulnerabilities, filter_param):
        """ Filter vulnerabilities depending on the scanner used"""

        def matches_pattern(column_data, pattern: str, **kwargs):
            """Performs pattern matching on dataframe
            Args:
                pattern : Regex pattern to look for
                column_data  :  The dataframe to perform filter

            **Kwargs     
                both_strings (bool): perform AND operation
                startsWith   (bool):   Search for a string that starts with           
            """

            if isinstance(pattern, re.Pattern):
                pattern = pattern.pattern  # Convert to string

            if kwargs.get("both_strings"):
                # trunk-ignore(ruff/B020)
                for p in pattern.split("|"):
                    result = column_data.str.contains(p, regex=True, na=False)
                return result

            if kwargs.get("startsWith"):

                result = column_data.str.startswith(pattern, na=False)
                # match(rf'{pattern}')  # startswith(pattern)
                return result

            result = column_data.str.contains(pattern, regex=True, na=False)
            return result

        # Filter Strings

        column_ = self.COLUMNS[self.scanner]  # COLUMNS['nessus']
        # Cache column data to avoid repetition
        # common column for both scanners
        title_data = vulnerabilities[column_.get("title")]
        solution_data = vulnerabilities[column_.get("solution")]

        if self.scanner == "nessus":
            description_data = vulnerabilities[column_.get("description")]
            risk_data = vulnerabilities[column_.get("risk")]
            synopsis_data = vulnerabilities[column_.get("synopsis")]
            # [risk, synopsis, Description]
            # Risk
            risk_mask = matches_pattern(
                risk_data, self._compiled_patterns["rating"])
            compliance_risk_mask = matches_pattern(
                risk_data, self._compiled_patterns["compliance"])

            # Description
            upgrade_description_mask = matches_pattern(
                description_data, self._compiled_patterns["software"])
            ssl_description_mask = matches_pattern(
                description_data, self._compiled_patterns['ssl'])
            patch_description_mask = matches_pattern(
                description_data, self._compiled_patterns["patch"])
            reboot_desc_mask = matches_pattern(description_data,
                                               self._compiled_patterns["reboot"])
            rdp_description_mask = matches_pattern(
                description_data, self._compiled_patterns["rdp"])
            rce_description_mask = matches_pattern(
                description_data, self._compiled_patterns["rce"])
            ssh_description_mask = matches_pattern(
                description_data, self._compiled_patterns["ssh"])
            web_description_mask = matches_pattern(
                description_data, self._compiled_patterns["web"])

            # Synopsis
            upgrade_synopsis_mask = matches_pattern(
                synopsis_data, self._compiled_patterns["software"])
            patch_synopsis_mask = matches_pattern(
                synopsis_data, self._compiled_patterns["patch"])
            ssh_synopsis_mask = matches_pattern(
                synopsis_data, self._compiled_patterns["ssh"])
            web_synopsis_mask = matches_pattern(
                synopsis_data, self._compiled_patterns["web"])
            info_synopsis_mask = matches_pattern(
                synopsis_data, self._compiled_patterns['info'])
            defender_synopsis_mask = matches_pattern(
                synopsis_data, self.regex_word("antimalware"))
            compliance_synopsis_mask = matches_pattern(
                synopsis_data, self.regex_word("Compliance checks")
            )

        elif self.scanner == "rapid":
            service_data = vulnerabilities[column_.get("service")]
            pci_data = vulnerabilities[column_.get("pci_status")]
            # [service, pci_data]
            compliance_mask = matches_pattern(
                pci_data, self.regex_word("Fail"))
            web_service_mask = matches_pattern(
                service_data, self._compiled_patterns["web"])
            ssh_service_mask = matches_pattern(
                service_data, self._compiled_patterns["ssh"])

        solution_starts_with_update = (matches_pattern(
            solution_data, "Update", startsWith=True))
        solution_starts_with_upgrade = (matches_pattern(
            solution_data, "Upgrade", startsWith=True))

        # [Title]
        upgrade_title_mask = matches_pattern(
            title_data, self._compiled_patterns["software"])
        ssl_title_mask = matches_pattern(
            title_data, self._compiled_patterns["ssl"])
        rdp_title_mask = matches_pattern(
            title_data, self._compiled_patterns["rdp"])
        web_title_mask = matches_pattern(
            title_data, self._compiled_patterns['web'])
        ssh_title_mask = matches_pattern(
            title_data, self._compiled_patterns['ssh'])
        ignore_web = matches_pattern(
            title_data, self._compiled_patterns["ignore_"]["web"])
        info_title_mask = matches_pattern(
            title_data, self._compiled_patterns['info'])
        db_title_mask = matches_pattern(
            title_data, self.regex_word("Database"))

        # [Solution]
        upgrade_solution_mask = matches_pattern(
            solution_data, self._compiled_patterns["software"])
        patch_solution_mask = matches_pattern(
            solution_data, self._compiled_patterns['patch'])
        ssl_solution_mask = matches_pattern(
            solution_data, self._compiled_patterns["ssl"])
        ignore_common_solution_mask = matches_pattern(
            solution_data, self._compiled_patterns["ignore_"]["common"])
        reboot_solution_mask = matches_pattern(
            solution_data, self._compiled_patterns["reboot"])
        web_solution_mask = matches_pattern(
            solution_data, self._compiled_patterns["web"])
        update_upgrade_solution = matches_pattern(
            solution_data, self._compiled_patterns["patch_or_upgrade"])
        registry_in_solution = matches_pattern(solution_data, self.regex_word(
            'registry'))

        def filter_upgrade_without_update(series):
            has_upgrade = series.str.contains(
                r'\bUpgrade\b', case=True, na=False, regex=True)
            has_update = series.str.contains(
                r'\bUpdate\b', case=True, na=False, regex=True)
            return has_upgrade & ~has_update

        def update_with_upgrade_pattern(series):
            has_update = series.str.contains(
                r'\bUpdate\b', case=True, na=False, regex=True)
            has_upgrade_pattern = series.str.contains(
                r'\bremove any affected versions\b', case=True, na=False, regex=True)
            return has_update & has_upgrade_pattern

        upgrade_pattern = (
            upgrade_title_mask
            | upgrade_solution_mask
            | upgrade_description_mask
            | upgrade_synopsis_mask
        )
        ssl_pattern = (
            (ssl_title_mask |
             ssl_description_mask)
            & ~(update_upgrade_solution |
                rdp_title_mask | patch_synopsis_mask |
                patch_solution_mask | web_title_mask)
        )
        FILTERS = {
            "ssl_condition": {
                "nessus": lambda: risk_mask & ssl_pattern,
                "rapid": lambda: (
                    ssl_title_mask
                    | ssl_solution_mask
                )
                & ~(
                    ignore_common_solution_mask
                    | patch_solution_mask
                    | upgrade_solution_mask
                ),
            },
            "missing_patch_condition": {
                "nessus": lambda: risk_mask &
                (
                    patch_solution_mask
                    | patch_synopsis_mask
                    | (patch_description_mask & patch_solution_mask)
                    | (patch_description_mask & update_with_upgrade_pattern(solution_data))
                )
                & ~(
                    upgrade_solution_mask |
                    upgrade_title_mask |
                    registry_in_solution  # Ignore registry solution
                ),
                "rapid": lambda: (
                    patch_solution_mask
                    & ~upgrade_solution_mask
                ),
            },
            "unsupported_software_condition": {
                # Filter unsupported software
                # 1. Name, Synopsis, Solution , Description columns contain software regex pattern
                #    - if pattern matches in any of the above columns, ensure solution doesnt start
                #       with Update
                # 2. Solution contains Update and Upgrade but starts with Upgrade
                "nessus": lambda: risk_mask &
                (solution_starts_with_upgrade
                 | upgrade_pattern
                 | filter_upgrade_without_update(solution_data))
                & ~solution_starts_with_update,
                "rapid": lambda: (
                    filter_upgrade_without_update(solution_data)
                    | upgrade_title_mask
                    & ~upgrade_solution_mask
                ),
            },
            "reboot_condition": {
                "any": lambda: (
                    risk_mask
                    & (reboot_desc_mask | reboot_solution_mask)
                )
                & ~(patch_solution_mask | upgrade_solution_mask)
            },
            # Simple pattern matches
            **{
                key: {
                    "any": lambda p=pattern: (risk_mask & matches_pattern(title_data, self.regex_word(p)))
                    & ~(patch_solution_mask)
                }
                for key, pattern in [
                    ("kaspersky_condition", "Kaspersky"),
                    ("insecure_condition", "Insecure Windows Service"),
                    ("winverify_condition", "WinVerifyTrust"),
                    ("unquoted_condition", "Unquoted Service Path"),
                    ("smb_condition", "SMB"),
                    ("speculative_condition", "Windows Speculative"),
                    ("AD_condition", "AD Starter"),
                ]
            },
            "defender_condition": {
                "any": lambda: risk_mask
                & defender_synopsis_mask
                & ~(patch_description_mask)
            },
            "rdp_condition": {
                "any": lambda: (rdp_title_mask | rdp_description_mask)
                & risk_mask
                & ~(ignore_common_solution_mask | patch_solution_mask)
            },
            "telnet_condition": {
                "any": lambda: matches_pattern(
                    title_data, self.regex_word("Telnet Server")
                )
            },
            "rce_condition": {
                "any": lambda: (risk_mask & rce_description_mask)
                & ~(ignore_common_solution_mask | patch_solution_mask)
            },
            "compliance_condition": {
                "nessus": lambda: (
                    compliance_risk_mask
                    & compliance_synopsis_mask
                ),
                "rapid": lambda: compliance_mask,
            },
            "ssh_condition": {
                "nessus": lambda: risk_mask &
                (
                    ssh_synopsis_mask
                    | ssh_description_mask
                    | ssh_title_mask
                )
                & ~ignore_common_solution_mask,
                "rapid": lambda: (
                    ssh_service_mask
                    & ~ignore_common_solution_mask
                )
                | ssh_title_mask,
            },
            "information_condition": {
                "any": lambda: risk_mask &
                (info_title_mask | info_synopsis_mask)
                & ~(
                    upgrade_solution_mask
                    | patch_solution_mask
                    | ssh_title_mask
                )

            },
            "database_condition": {
                "any": lambda: (
                    risk_mask
                    & db_title_mask
                    & ~ignore_common_solution_mask
                )
            },
            "web_condition": {
                "nessus": lambda: (
                    risk_mask
                )
                & (
                    web_title_mask
                    | web_description_mask
                    | web_synopsis_mask
                    | web_solution_mask
                )
                & ~(
                    ssh_title_mask
                    | ignore_common_solution_mask
                    | patch_solution_mask
                    | patch_synopsis_mask
                    | patch_description_mask
                    | ssl_pattern
                    | matches_pattern(
                        title_data, self.regex_word("Information Disclosure")
                    )
                ),
                "rapid": lambda: (
                    ~(
                        ignore_web
                        | upgrade_solution_mask
                        | patch_solution_mask
                    )
                    & web_service_mask
                ),
            },
        }

        scanner = self.scanner if self.scanner in self.SCANNERS else "any"
        if filter_param in FILTERS:
            condition = FILTERS[filter_param].get(
                scanner, FILTERS[filter_param].get("any")
            )
            return {filter_param: condition()}
        else:
            return {}
# trunk-ignore-all(black)

from ..shared import VAConfigs, CustomDecorators
import re


class FilterVulnerabilities(VAConfigs, CustomDecorators):
    """Filters vulnerabilities depending on scanner used"""

    def __init__(self):
        super().__init__()
        self.scanner = None

        # self.filter_vulnerabilities = self.decorators.measure_execution_time(
        #     self.filter_vulnerabilities)

    SCANNERS = ["nessus", "rapid"]

    def update_scanner(self, scanner):
        self.scanner = scanner

    @property
    def reset_timer(self):
        """Reset the timer"""
        self.timer.reset_total_time()

    @staticmethod
    def percentage_null_fields(dataframe):
        # determine percentage accuracy of the data by showing null fields
        for i in dataframe.columns:
            null_rate = dataframe[i].isna().sum() / len(dataframe) * 100
            if null_rate > 0:
                print(f"{i} null rate: {null_rate:.2f}%")

    @staticmethod
    def csv_filter_operations(dataframe, filter_option, operation, **kwargs):
        # Function to combine all the major CSV filters into one for code clarity
        match operation:
            case "notnull":
                return dataframe[filter_option].notna()
            case "contains":
                if "contains_key" in kwargs:
                    # check for any key value pair passed as an extra argument and uses it as a filter
                    return dataframe[filter_option].str.contains(kwargs["contains_key"])
            case "in":
                if "in_key" in kwargs:
                    return dataframe[filter_option].isin(kwargs["in_key"])
            case _:
                raise ValueError(f"Invalid filter option: {filter_option}")

    @staticmethod
    def regex_word(search_term: str, **kwargs):
        """Performs a regex check against a given term
        :param  search_term: string containing the characters to search for
        :param  kwargs:
        Return str
                checks for text that has the first term but not the second

        Return bool
        """
        if kwargs.get("second_term"):
            return rf'\b{search_term}\b(?!.*\b{kwargs["second_term"]}\b)'
        return rf"\b{search_term}\b"

    @CustomDecorators.measure_execution_time
    def filter_vulnerabilities(self, vulnerabilities, filter_param):
        """ Filter vulnerabilities depending on the scanner used"""

        def matches_pattern(column_data, pattern: str, **kwargs):
            """Performs pattern matching on dataframe
            Args:
                pattern : Regex pattern to look for
                column_data  :  The dataframe to perform filter

            **Kwargs     
                both_strings (bool): perform AND operation
                startsWith   (bool):   Search for a string that starts with           
            """

            if isinstance(pattern, re.Pattern):
                pattern = pattern.pattern  # Convert to string

            if kwargs.get("both_strings"):
                # trunk-ignore(ruff/B020)
                for p in pattern.split("|"):
                    result = column_data.str.contains(p, regex=True, na=False)
                return result

            if kwargs.get("startsWith"):

                result = column_data.str.startswith(pattern, na=False)
                # match(rf'{pattern}')  # startswith(pattern)
                return result

            result = column_data.str.contains(pattern, regex=True, na=False)
            return result

        # Filter Strings

        column_ = self.COLUMNS[self.scanner]  # COLUMNS['nessus']
        # Cache column data to avoid repetition
        # common column for both scanners
        title_data = vulnerabilities[column_.get("title")]
        solution_data = vulnerabilities[column_.get("solution")]

        if self.scanner == "nessus":
            description_data = vulnerabilities[column_.get("description")]
            risk_data = vulnerabilities[column_.get("risk")]
            synopsis_data = vulnerabilities[column_.get("synopsis")]
            # [risk, synopsis, Description]
            # Risk
            risk_mask = matches_pattern(
                risk_data, self._compiled_patterns["rating"])
            compliance_risk_mask = matches_pattern(
                risk_data, self._compiled_patterns["compliance"])

            # Description
            upgrade_description_mask = matches_pattern(
                description_data, self._compiled_patterns["software"])
            ssl_description_mask = matches_pattern(
                description_data, self._compiled_patterns['ssl'])
            patch_description_mask = matches_pattern(
                description_data, self._compiled_patterns["patch"])
            reboot_desc_mask = matches_pattern(description_data,
                                               self._compiled_patterns["reboot"])
            rdp_description_mask = matches_pattern(
                description_data, self._compiled_patterns["rdp"])
            rce_description_mask = matches_pattern(
                description_data, self._compiled_patterns["rce"])
            ssh_description_mask = matches_pattern(
                description_data, self._compiled_patterns["ssh"])
            web_description_mask = matches_pattern(
                description_data, self._compiled_patterns["web"])

            # Synopsis
            upgrade_synopsis_mask = matches_pattern(
                synopsis_data, self._compiled_patterns["software"])
            patch_synopsis_mask = matches_pattern(
                synopsis_data, self._compiled_patterns["patch"])
            ssh_synopsis_mask = matches_pattern(
                synopsis_data, self._compiled_patterns["ssh"])
            web_synopsis_mask = matches_pattern(
                synopsis_data, self._compiled_patterns["web"])
            info_synopsis_mask = matches_pattern(
                synopsis_data, self._compiled_patterns['info'])
            defender_synopsis_mask = matches_pattern(
                synopsis_data, self.regex_word("antimalware"))
            compliance_synopsis_mask = matches_pattern(
                synopsis_data, self.regex_word("Compliance checks")
            )

        elif self.scanner == "rapid":
            service_data = vulnerabilities[column_.get("service")]
            pci_data = vulnerabilities[column_.get("pci_status")]
            # [service, pci_data]
            compliance_mask = matches_pattern(
                pci_data, self.regex_word("Fail"))
            web_service_mask = matches_pattern(
                service_data, self._compiled_patterns["web"])
            ssh_service_mask = matches_pattern(
                service_data, self._compiled_patterns["ssh"])

        solution_starts_with_update = (matches_pattern(
            solution_data, "Update", startsWith=True))
        solution_starts_with_upgrade = (matches_pattern(
            solution_data, "Upgrade", startsWith=True))

        # [Title]
        upgrade_title_mask = matches_pattern(
            title_data, self._compiled_patterns["software"])
        ssl_title_mask = matches_pattern(
            title_data, self._compiled_patterns["ssl"])
        rdp_title_mask = matches_pattern(
            title_data, self._compiled_patterns["rdp"])
        web_title_mask = matches_pattern(
            title_data, self._compiled_patterns['web'])
        ssh_title_mask = matches_pattern(
            title_data, self._compiled_patterns['ssh'])
        ignore_web = matches_pattern(
            title_data, self._compiled_patterns["ignore_"]["web"])
        info_title_mask = matches_pattern(
            title_data, self._compiled_patterns['info'])
        db_title_mask = matches_pattern(
            title_data, self.regex_word("Database"))

        # [Solution]
        upgrade_solution_mask = matches_pattern(
            solution_data, self._compiled_patterns["software"])
        patch_solution_mask = matches_pattern(
            solution_data, self._compiled_patterns['patch'])
        ssl_solution_mask = matches_pattern(
            solution_data, self._compiled_patterns["ssl"])
        ignore_common_solution_mask = matches_pattern(
            solution_data, self._compiled_patterns["ignore_"]["common"])
        reboot_solution_mask = matches_pattern(
            solution_data, self._compiled_patterns["reboot"])
        web_solution_mask = matches_pattern(
            solution_data, self._compiled_patterns["web"])
        update_upgrade_solution = matches_pattern(
            solution_data, self._compiled_patterns["patch_or_upgrade"])
        registry_in_solution = matches_pattern(solution_data, self.regex_word(
            'registry'))

        def filter_upgrade_without_update(series):
            has_upgrade = series.str.contains(
                r'\bUpgrade\b', case=True, na=False, regex=True)
            has_update = series.str.contains(
                r'\bUpdate\b', case=True, na=False, regex=True)
            return has_upgrade & ~has_update
        
        def update_with_upgrade_pattern(series):
            has_update = series.str.contains(
                r'\bUpdate\b', case=True, na=False, regex=True)
            has_upgrade_pattern = series.str.contains(
                r'\bremove any affected versions\b', case=True, na=False, regex=True)
            return has_update & has_upgrade_pattern

        upgrade_pattern = (
            upgrade_title_mask
            | upgrade_solution_mask
            | upgrade_description_mask
            | upgrade_synopsis_mask
        )
        ssl_pattern = (
            (ssl_title_mask |
             ssl_description_mask)
            & ~(update_upgrade_solution |
                rdp_title_mask | patch_synopsis_mask |
                patch_solution_mask | web_title_mask)
        )
        FILTERS = {
            "ssl_condition": {
                "nessus": lambda: risk_mask & ssl_pattern,
                "rapid": lambda: (
                    ssl_title_mask
                    | ssl_solution_mask
                )
                & ~(
                    ignore_common_solution_mask
                    | patch_solution_mask
                    | upgrade_solution_mask
                ),
            },
            "missing_patch_condition": {
                "nessus": lambda: risk_mask &
                (
                    patch_solution_mask
                    | patch_synopsis_mask
                    | (patch_description_mask & patch_solution_mask)
                    
                )
                & ~(
                    (upgrade_solution_mask & ~update_with_upgrade_pattern(solution_data)) 
                    |upgrade_title_mask 
                    |registry_in_solution  # Ignore registry solution
                ),
                "rapid": lambda: (
                    patch_solution_mask
                    & ~upgrade_solution_mask
                ),
            },
            "unsupported_software_condition": {
                # Filter unsupported software
                # 1. Name, Synopsis, Solution , Description columns contain software regex pattern
                #    - if pattern matches in any of the above columns, ensure solution doesnt start
                #       with Update
                # 2. Solution contains Update and Upgrade but starts with Upgrade
                "nessus": lambda: risk_mask &
                (solution_starts_with_upgrade
                 | upgrade_pattern
                 | filter_upgrade_without_update(solution_data))
                & ~solution_starts_with_update,
                "rapid": lambda: (
                    filter_upgrade_without_update(solution_data)
                    | upgrade_title_mask
                    & ~upgrade_solution_mask
                ),
            },
            "reboot_condition": {
                "any": lambda: (
                    risk_mask
                    & (reboot_desc_mask | reboot_solution_mask)
                )
                & ~(patch_solution_mask | upgrade_solution_mask)
            },
            # Simple pattern matches
            **{
                key: {
                    "any": lambda p=pattern: (risk_mask & matches_pattern(title_data, self.regex_word(p)))
                    & ~(patch_solution_mask)
                }
                for key, pattern in [
                    ("kaspersky_condition", "Kaspersky"),
                    ("insecure_condition", "Insecure Windows Service"),
                    ("winverify_condition", "WinVerifyTrust"),
                    ("unquoted_condition", "Unquoted Service Path"),
                    ("smb_condition", "SMB"),
                    ("speculative_condition", "Windows Speculative"),
                    ("AD_condition", "AD Starter"),
                ]
            },
            "defender_condition": {
                "any": lambda: risk_mask
                & defender_synopsis_mask
                & ~(patch_description_mask)
            },
            "rdp_condition": {
                "any": lambda: (rdp_title_mask | rdp_description_mask)
                & risk_mask
                & ~(ignore_common_solution_mask | patch_solution_mask)
            },
            "telnet_condition": {
                "any": lambda: matches_pattern(
                    title_data, self.regex_word("Telnet Server")
                )
            },
            "rce_condition": {
                "any": lambda: (risk_mask & rce_description_mask)
                & ~(ignore_common_solution_mask | patch_solution_mask)
            },
            "compliance_condition": {
                "nessus": lambda: (
                    compliance_risk_mask
                    & compliance_synopsis_mask
                ),
                "rapid": lambda: compliance_mask,
            },
            "ssh_condition": {
                "nessus": lambda: risk_mask &
                (
                    ssh_synopsis_mask
                    | ssh_description_mask
                    | ssh_title_mask
                )
                & ~ignore_common_solution_mask,
                "rapid": lambda: (
                    ssh_service_mask
                    & ~ignore_common_solution_mask
                )
                | ssh_title_mask,
            },
            "information_condition": {
                "any": lambda: risk_mask &
                (info_title_mask | info_synopsis_mask)
                & ~(
                    upgrade_solution_mask
                    | patch_solution_mask
                    | ssh_title_mask
                )

            },
            "database_condition": {
                "any": lambda: (
                    risk_mask
                    & db_title_mask
                    & ~ignore_common_solution_mask
                )
            },
            "web_condition": {
                "nessus": lambda: (
                    risk_mask
                )
                & (
                    web_title_mask
                    | web_description_mask
                    | web_synopsis_mask
                    | web_solution_mask
                )
                & ~(
                    ssh_title_mask
                    | ignore_common_solution_mask
                    | patch_solution_mask
                    | patch_synopsis_mask
                    | patch_description_mask
                    | ssl_pattern
                    | matches_pattern(
                        title_data, self.regex_word("Information Disclosure")
                    )
                ),
                "rapid": lambda: (
                    ~(
                        ignore_web
                        | upgrade_solution_mask
                        | patch_solution_mask
                    )
                    & web_service_mask
                ),
            },
        }

        scanner = self.scanner if self.scanner in self.SCANNERS else "any"
        if filter_param in FILTERS:
            condition = FILTERS[filter_param].get(
                scanner, FILTERS[filter_param].get("any")
            )
            return {filter_param: condition()}
        else:
            return {}
