# trunk-ignore-all(black)

from ..shared import VAConfigs


class FilterVulnerabilities(VAConfigs):
    """Filters vulnerabilities depending on scanner used"""

    def __init__(self):
        super().__init__()
        self.scanner = None

    SCANNERS = ["nessus", "rapid"]

    def update_scanner(self, scanner):
        self.scanner = scanner

    # @staticmethod
    # def _compile_regex(pattern):
    #     return re.compile(pattern)

    @staticmethod
    def percentage_null_fields(dataframe):
        # determine percentage accuracy of the data by showing null fields
        for i in dataframe.columns:
            null_rate = dataframe[i].isna().sum() / len(dataframe) * 100
            if null_rate > 0:
                print(f"{i} null rate: {null_rate:.2f}%")

    @staticmethod
    def csv_filter_operations(dataframe, filter_option, operation, **kwargs):
        # Function to combine all the major CSV filters into one for code clarity
        match operation:
            case "notnull":
                return dataframe[filter_option].notna()
            case "contains":
                if "contains_key" in kwargs:
                    # check for any key value pair passed as an extra argument and uses it as a filter
                    return dataframe[filter_option].str.contains(kwargs["contains_key"])
            case "in":
                if "in_key" in kwargs:
                    return dataframe[filter_option].isin(kwargs["in_key"])
            case _:
                raise ValueError(f"Invalid filter option: {filter_option}")

    @staticmethod
    def regex_word(search_term: str, **kwargs):
        """Performs a regex check against a given term
        :param  search_term: string containing the characters to search for
        :param  kwargs:
        Return str
                checks for text that has the first term but not the second

        Return bool
        """
        if kwargs.get("second_term"):
            return rf'\b{search_term}\b(?!.*\b{kwargs["second_term"]}\b)'
        return rf"\b{search_term}\b"


    def filter_vulnerabilities(self, vulnerabilities, filter_param):
        """ Filter vulnerabilities depending on the scanner used"""

        def matches_pattern(column_data: str, pattern: str, **kwargs):
            """Performs pattern matching on dataframe
            Args:
                pattern (str): Regex pattern to look for
                column_data  :  The dataframe to perform filter

            **Kwargs     
                both_strings (bool): perform AND operation
                startsWith   (bool):   Search for a string that starts with           
            """
            if kwargs.get("both_strings"):
                # trunk-ignore(ruff/B020)
                for p in pattern.split("|"):
                    result = column_data.str.contains(p, regex=True, na=False)
                return result

            if kwargs.get("startsWith"):
                result = column_data.str.startswith(pattern, na=False)
                # match(rf'{pattern}')  # startswith(pattern)
                return result

            result = column_data.str.contains(pattern, regex=True, na=False)
            return result

        # Filter Strings

        column_ = self.COLUMNS[self.scanner]  # COLUMNS['nessus']
        # Cache column data to avoid repetition
        # common column for both scanners
        title_data = vulnerabilities[column_.get("title")]
        solution_data = vulnerabilities[column_.get("solution")]

        if self.scanner == "nessus":
            description_data = vulnerabilities[column_.get("description")]
            risk_data = vulnerabilities[column_.get("risk")]
            synopsis_data = vulnerabilities[column_.get("synopsis")]

        elif self.scanner == "rapid":
            service_data = vulnerabilities[column_.get("service")]
            pci_data = vulnerabilities[column_.get("pci_status")]

        solution_starts_with_update = (matches_pattern(
            solution_data, "Update", startsWith=True))
        solution_starts_with_upgrade = (matches_pattern(
            solution_data, "Upgrade", startsWith=True))
        upgrade_pattern = (
            matches_pattern(title_data, self._compiled_patterns["software"])
            | matches_pattern(solution_data, self._compiled_patterns["software"])
            | matches_pattern(description_data, self._compiled_patterns["software"])
            | matches_pattern(synopsis_data, self._compiled_patterns["software"])
        )

        FILTERS = {
            "ssl_condition": {
                "nessus": lambda: matches_pattern(risk_data, self._compiled_patterns["rating"]) &
                (matches_pattern(title_data, self._compiled_patterns["ssl"]) |
                 matches_pattern(description_data, self._compiled_patterns['ssl']))
                & ~(matches_pattern(solution_data, self._compiled_patterns["patch_or_upgrade"]) |
                    matches_pattern(title_data, self._compiled_patterns["rdp"]) |
                    matches_pattern(synopsis_data, self._compiled_patterns["patch"]) |
                    matches_pattern(solution_data, self._compiled_patterns['patch']) |
                    matches_pattern(title_data, self._compiled_patterns['web'])),
                "rapid": lambda: (
                    matches_pattern(title_data,
                                    self._compiled_patterns["ssl"])
                    | matches_pattern(solution_data, self._compiled_patterns["ssl"])
                    & matches_pattern(risk_data, self._compiled_patterns["rating"])
                )
                & ~(
                    matches_pattern(
                        solution_data, self._compiled_patterns["ignore_"]["common"])
                    | matches_pattern(solution_data, self._compiled_patterns["patch"])
                    | matches_pattern(solution_data, self._compiled_patterns["software"])
                ),
            },
            "missing_patch_condition": {
                "nessus": lambda: matches_pattern(risk_data, self._compiled_patterns["rating"]) &
                (
                    matches_pattern(
                        solution_data, self._compiled_patterns["patch"])
                    | matches_pattern(synopsis_data, self._compiled_patterns["patch"])
                    | (  # ignore where Description has update but solution does not involve update
                        matches_pattern(description_data, self._compiled_patterns["patch"]) &
                        matches_pattern(
                            solution_data, self._compiled_patterns['patch'])
                    ))
                & ~(
                    matches_pattern(solution_data, self._compiled_patterns["software"]) |
                    matches_pattern(title_data, self._compiled_patterns['software']) |
                    matches_pattern(solution_data, self.regex_word(
                        'registry'))  # Ignore registry solution
                ),
                "rapid": lambda: (
                    matches_pattern(
                        solution_data, self._compiled_patterns["patch"])
                    & ~matches_pattern(solution_data, self._compiled_patterns["software"])
                ),
            },
            "unsupported_software_condition": {
                # Filter unsupported software
                # 1. Name, Synopsis, Solution , Description columns contain software regex pattern
                #    - if pattern matches in any of the above columns, ensure solution doesnt start
                #       with Update
                # 2. Solution contains Update and Upgrade but starts with Upgrade
                "nessus": lambda: matches_pattern(risk_data, self._compiled_patterns["rating"]) &
                (solution_starts_with_upgrade
                 | upgrade_pattern) &
                ~solution_starts_with_update,
                "rapid": lambda: (
                    matches_pattern(solution_data, self.regex_word(
                        "Upgrade", second_term="Update"))
                    | matches_pattern(title_data, self._compiled_patterns["software"])
                    & ~matches_pattern(solution_data, self._compiled_patterns["patch"])
                ),
            },
            "reboot_condition": {
                "any": lambda: (
                    matches_pattern(
                        risk_data, self._compiled_patterns["rating"])
                    & (
                        matches_pattern(description_data,
                                        self._compiled_patterns["reboot"])
                        | matches_pattern(solution_data, self._compiled_patterns["reboot"])
                    )
                )
                & ~(
                    matches_pattern(
                        solution_data, self._compiled_patterns["patch"])
                    | matches_pattern(solution_data, self._compiled_patterns["software"])
                )
            },
            # Simple pattern matches
            **{
                key: {
                    "any": lambda p=pattern: (matches_pattern(risk_data, self._compiled_patterns["rating"])
                                              & matches_pattern(title_data, self.regex_word(p)))
                    & ~(matches_pattern(solution_data, self._compiled_patterns['patch']))
                }
                for key, pattern in [
                    ("kaspersky_condition", "Kaspersky"),
                    ("insecure_condition", "Insecure Windows Service"),
                    ("winverify_condition", "WinVerifyTrust"),
                    ("unquoted_condition", "Unquoted Service Path"),
                    ("smb_condition", "SMB"),
                    ("speculative_condition", "Windows Speculative"),
                    ("AD_condition", "AD Starter"),
                ]
            },
            "defender_condition": {
                "any": lambda: matches_pattern(risk_data, self._compiled_patterns["rating"])
                & matches_pattern(synopsis_data, self.regex_word("antimalware")
                                  )
                & ~(matches_pattern(description_data, self._compiled_patterns["patch"]))
            },
            "rdp_condition": {
                "any": lambda: (
                    matches_pattern(title_data, self._compiled_patterns["rdp"])
                    | matches_pattern(description_data, self._compiled_patterns["rdp"])
                )
                & matches_pattern(risk_data, self._compiled_patterns["rating"])
                & ~(
                    matches_pattern(
                        solution_data, self._compiled_patterns["ignore_"]["common"])
                    | matches_pattern(solution_data, self._compiled_patterns["patch"])
                )
            },
            "telnet_condition": {
                "any": lambda: matches_pattern(
                    title_data, self.regex_word("Telnet Server")
                )
            },
            "rce_condition": {
                "any": lambda: (matches_pattern(risk_data, self._compiled_patterns["rating"]) &
                                matches_pattern(
                                    description_data, self._compiled_patterns["rce"])
                                )
                & ~(
                    matches_pattern(
                        solution_data, self._compiled_patterns["ignore_"]["common"])
                    | matches_pattern(solution_data, self._compiled_patterns["patch"])
                )
            },
            "compliance_condition": {
                "nessus": lambda: (
                    matches_pattern(
                        risk_data, self._compiled_patterns["compliance"])
                    & matches_pattern(
                        synopsis_data, self.regex_word("Compliance checks")
                    )
                ),
                "rapid": lambda: matches_pattern(pci_data, self.regex_word("Fail")),
            },
            "ssh_condition": {
                "nessus": lambda: matches_pattern(risk_data, self._compiled_patterns["rating"]) &
                (
                    matches_pattern(synopsis_data, self._compiled_patterns["ssh"]) |
                    matches_pattern(description_data, self._compiled_patterns["ssh"]) |
                    matches_pattern(title_data, self._compiled_patterns['ssh'])
                )
                & ~matches_pattern(solution_data, self._compiled_patterns["ignore_"]["common"]),
                "rapid": lambda: (
                    matches_pattern(
                        service_data, self._compiled_patterns["ssh"])
                    & ~matches_pattern(
                        solution_data, self._compiled_patterns["ignore_"]["common"]
                    )
                )
                | matches_pattern(title_data, self.regex_word("SSH Server")),
            },
            "information_condition": {
                "any": lambda: matches_pattern(risk_data, self._compiled_patterns["rating"]) &
                (matches_pattern(title_data, self._compiled_patterns['info']) |
                 matches_pattern(synopsis_data, self._compiled_patterns['info']))
                & ~(
                    matches_pattern(solution_data,
                                    self._compiled_patterns["software"])
                    | matches_pattern(solution_data, self._compiled_patterns["patch"])
                    | matches_pattern(title_data, self._compiled_patterns["ssl"])
                )

            },
            "database_condition": {
                "any": lambda: (
                    matches_pattern(
                        risk_data, self._compiled_patterns["rating"])
                    & matches_pattern(title_data, self.regex_word("Database"))
                    & ~matches_pattern(solution_data, self._compiled_patterns["ignore_"]["common"]
                                       )
                )
            },
            "web_condition": {
                "nessus": lambda: (
                    matches_pattern(
                        risk_data, self._compiled_patterns["rating"])
                )
                & (
                    matches_pattern(title_data, self._compiled_patterns["web"])
                    | matches_pattern(description_data, self._compiled_patterns["web"])
                    | matches_pattern(synopsis_data, self._compiled_patterns["web"])
                    | matches_pattern(solution_data, self._compiled_patterns["web"])
                )
                & ~(
                    matches_pattern(title_data, self._compiled_patterns["ssl"])
                    | matches_pattern(
                        solution_data, self._compiled_patterns["ignore_"]["common"]
                    )
                    | matches_pattern(solution_data, self._compiled_patterns["patch"])
                    | matches_pattern(synopsis_data, self._compiled_patterns["patch"])
                    | matches_pattern(description_data, self._compiled_patterns["patch"])
                    | matches_pattern(
                        title_data, self.regex_word("Information Disclosure")
                    )
                ),
                "rapid": lambda: (
                    ~(
                        matches_pattern(
                            title_data, self._compiled_patterns["ignore_"]["web"])
                        | matches_pattern(solution_data, self._compiled_patterns["software"])
                        | matches_pattern(solution_data, self._compiled_patterns["patch"])
                    )
                    & matches_pattern(service_data, self._compiled_patterns["web"])
                ),
            },
        }

        scanner = self.scanner if self.scanner in self.SCANNERS else "any"
        if filter_param in FILTERS:
            condition = FILTERS[filter_param].get(
                scanner, FILTERS[filter_param].get("any")
            )
            return {filter_param: condition()}
        else:
            return {}
