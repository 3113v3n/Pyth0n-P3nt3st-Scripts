# trunk-ignore-all(black)

from ..shared import VAConfigs


class FilterVulnerabilities(VAConfigs):
    """Filters vulnerabilities depending on scanner used"""

    def __init__(self):
        super().__init__()
        self.scanner = None

    SCANNERS = ["nessus", "rapid"]

    def update_scanner(self, scanner):
        self.scanner = scanner

    # @staticmethod
    # def _compile_regex(pattern):
    #     return re.compile(pattern)

    @staticmethod
    def percentage_null_fields(dataframe):
        # determine percentage accuracy of the data by showing null fields
        for i in dataframe.columns:
            null_rate = dataframe[i].isna().sum() / len(dataframe) * 100
            if null_rate > 0:
                print(f"{i} null rate: {null_rate:.2f}%")

    @staticmethod
    def csv_filter_operations(dataframe, filter_option, operation, **kwargs):
        # Function to combine all the major CSV filters into one for code clarity
        match operation:
            case "notnull":
                return dataframe[filter_option].notna()
            case "contains":
                if "contains_key" in kwargs:
                    # check for any key value pair passed as an extra argument and uses it as a filter
                    return dataframe[filter_option].str.contains(kwargs["contains_key"])
            case "in":
                if "in_key" in kwargs:
                    return dataframe[filter_option].isin(kwargs["in_key"])
            case _:
                raise ValueError(f"Invalid filter option: {filter_option}")

    @staticmethod
    def regex_word(search_term: str, **kwargs):
        """Performs a regex check against a given term
        :param  search_term: string containing the characters to search for
        :param  kwargs:
        Return str
                checks for text that has the first term but not the second

        Return bool
        """
        if kwargs.get("second_term"):
            return rf'\b{search_term}\b(?!.*\b{kwargs["second_term"]}\b)'
        return rf"\b{search_term}\b"

    @staticmethod
    def loop_through_files(
        file_list: list,
        start_file,
        read_csv: callable,  # reference a callable function
        original_datafile,
        error_text: str,
        get_missing_columns: callable,
        concat_dataframes: callable,
        read_xlsx: callable,
        get_file_extension: callable,
    ):
        """
        Process multiple files and combine their data
        Args:
            file_list: List of files to process
            start_file: Initial file path
            read_csv: Function to read CSV files
            original_datafile: Initial dataframe to compare against
            error_text: Error message for column mismatch
            get_missing_columns: Function to check missing columns
            concat_dataframes: Function to combine dataframes
            read_xlsx: Function to read Excel files
            get_file_extension: Function to get file extension
        """
        vulnerabilities_dataframe = [
            original_datafile]  # append new dataframes here

        for file in file_list:
            full_file_path = file["full_path"]

            if full_file_path != start_file:
                try:

                    file_extension = get_file_extension(full_file_path)

                    # Use relevant pandas method depending on file
                    if file_extension.lower() in ["xlsx", "xls"]:
                        new_data = read_xlsx(full_file_path, header=None)
                    elif file_extension.lower() == "csv":
                        new_data = read_csv(full_file_path, header=None)
                    else:
                        raise ValueError(
                            f"Unsupported file extension: {file_extension}"
                        )
                        # continue
                    # Check if new data is empty
                    if new_data.empty:
                        print(f"Skipping empty file : {file['filename']}")
                        continue

                    # Ensure columns match
                    if original_datafile.shape[1] != new_data.shape[1]:
                        print(
                            f"New file {file['filename']} has "
                            f"{len(new_data.columns)} columns "
                        )
                        raise ValueError(error_text)

                    # Check if other files have missing columns
                    get_missing_columns(new_data, file["filename"])
                    # Append new data to the original data
                    vulnerabilities_dataframe.append(new_data)
                except Exception as e:
                    print(f"Error processing file {file['filename']}: {e}")
                    continue

        if len(vulnerabilities_dataframe) == 1:
            return vulnerabilities_dataframe[0]
        return concat_dataframes(vulnerabilities_dataframe)

    def filter_vulnerabilities(self, vulnerabilities, filter_param):
        """ Filter vulnerabilities depending on the scanner used"""

        def matches_pattern(column_data: str, pattern: str, **kwargs):
            """Performs pattern matching on dataframe
            Args:
                pattern (str): Regex pattern to look for
                column_data  :  The dataframe to perform filter

            **Kwargs     
                both_strings (bool): perform AND operation
                startsWith   (bool):   Search for a string that starts with           
            """

            if kwargs.get("both_strings"):
                # trunk-ignore(ruff/B020)
                for pattern in pattern.split("|"):
                    result = column_data.str.contains(
                        pattern, regex=True, na=False
                    )
                return result

            if kwargs.get("startsWith"):
                result = column_data.str.startswith(
                    pattern)
                # match(rf'{pattern}')  # startswith(pattern)
                return result

            result = column_data.str.contains(
                pattern, regex=True, na=False)

            return result

        # Filter Strings

        column_ = self.COLUMNS[self.scanner]  # COLUMNS['nessus']

        # Cache column data to avoid repetition
        title_data = vulnerabilities[column_.get("title")]
        solution_data = vulnerabilities[column_.get("solution")]
        description_data = vulnerabilities[column_.get("description")]
        risk_data = vulnerabilities[column_.get("risk")]
        synopsis_data = vulnerabilities[column_.get("synopsis")]
        service_data = vulnerabilities[column_.get("service")]
        pci_data = vulnerabilities[column_.get("pci_status")]

        solution_starts_with_update = matches_pattern(
            column=solution_data,
            pattern="Update",
            startsWith=True)

        solution_starts_with_upgrade = matches_pattern(
            column=solution_data,
            pattern="Upgrade",
            startsWith=True)
        upgrade_pattern = (
            matches_pattern(title_data, self._compiled_patterns["software"])
            | matches_pattern(solution_data, self._compiled_patterns["software"])
            | matches_pattern(description_data, self._compiled_patterns["software"])
            | matches_pattern(synopsis_data, self._compiled_patterns["software"])
        )

        FILTERS = {
            "ssl_condition": {
                "nessus": lambda: matches_pattern(risk_data, self._compiled_patterns["rating"]) &
                (matches_pattern(title_data, self._compiled_patterns["ssl"]) |
                 matches_pattern(description_data, self._compiled_patterns['ssl']))
                & ~(matches_pattern(solution_data, self._compiled_patterns["patch_or_upgrade"]) |
                    matches_pattern(title_data, self._compiled_patterns["rdp"]) |
                    matches_pattern(synopsis_data, self._compiled_patterns["patch"]) |
                    matches_pattern(solution_data, self._compiled_patterns['patch']) |
                    matches_pattern(title_data, self._compiled_patterns['web'])),
                "rapid": lambda: (
                    matches_pattern(title_data,
                                    self._compiled_patterns["ssl"])
                    | matches_pattern(solution_data, self._compiled_patterns["ssl"])
                    & matches_pattern(risk_data, self._compiled_patterns["rating"])
                )
                & ~(
                    matches_pattern(
                        solution_data, self._compiled_patterns["ignore_"]["common"])
                    | matches_pattern(solution_data, self._compiled_patterns["patch"])
                    | matches_pattern(solution_data, self._compiled_patterns["software"])
                ),
            },
            "missing_patch_condition": {
                "nessus": lambda: matches_pattern(risk_data, self._compiled_patterns["rating"]) &
                (
                    matches_pattern(
                        solution_data, self._compiled_patterns["patch"])
                    | matches_pattern(synopsis_data, self._compiled_patterns["patch"])
                    | (  # ignore where Description has update but solution does not involve update
                        matches_pattern(description_data, self._compiled_patterns["patch"]) &
                        matches_pattern(
                            solution_data, self._compiled_patterns['patch'])
                    ))
                & ~(
                    matches_pattern(solution_data, self._compiled_patterns["software"]) |
                    matches_pattern(title_data, self._compiled_patterns['software']) |
                    matches_pattern(solution_data, self.regex_word(
                        'registry'))  # Ignore registry solution
                ),
                "rapid": lambda: (
                    matches_pattern(
                        solution_data, self._compiled_patterns["patch"])
                    & ~matches_pattern(solution_data, self._compiled_patterns["software"])
                ),
            },
            "unsupported_software_condition": {
                # Filter unsupported software
                # 1. Name, Synopsis, Solution , Description columns contain software regex pattern
                #    - if pattern matches in any of the above columns, ensure solution doesnt start
                #       with Update
                # 2. Solution contains Update and Upgrade but starts with Upgrade
                "nessus": lambda: matches_pattern(risk_data, self._compiled_patterns["rating"]) &
                (solution_starts_with_upgrade
                 | upgrade_pattern) & ~solution_starts_with_update,
                "rapid": lambda: (
                    matches_pattern(solution_data, self.regex_word(
                        "Upgrade", second_term="Update"))
                    | matches_pattern(title_data, self._compiled_patterns["software"])
                    & ~matches_pattern(solution_data, self._compiled_patterns["patch"])
                ),
            },
            "reboot_condition": {
                "any": lambda: (
                    matches_pattern(
                        risk_data, self._compiled_patterns["rating"])
                    & (
                        matches_pattern(description_data,
                                        self._compiled_patterns["reboot"])
                        | matches_pattern(solution_data, self._compiled_patterns["reboot"])
                    )
                )
                & ~(
                    matches_pattern(
                        solution_data, self._compiled_patterns["patch"])
                    | matches_pattern(solution_data, self._compiled_patterns["software"])
                )
            },
            # Simple pattern matches
            **{
                key: {
                    "any": lambda p=pattern: (matches_pattern(risk_data, self._compiled_patterns["rating"])
                                              & matches_pattern(title_data, self.regex_word(p)))
                    & ~(matches_pattern(solution_data, self._compiled_patterns['patch']))
                }
                for key, pattern in [
                    ("kaspersky_condition", "Kaspersky"),
                    ("insecure_condition", "Insecure Windows Service"),
                    ("winverify_condition", "WinVerifyTrust"),
                    ("unquoted_condition", "Unquoted Service Path"),
                    ("smb_condition", "SMB"),
                    ("speculative_condition", "Windows Speculative"),
                    ("AD_condition", "AD Starter"),
                ]
            },
            "defender_condition": {
                "any": lambda: matches_pattern(risk_data, self._compiled_patterns["rating"])
                & matches_pattern(synopsis_data, self.regex_word("antimalware")
                                  )
                & ~(matches_pattern(description_data, self._compiled_patterns["patch"]))
            },
            "rdp_condition": {
                "any": lambda: (
                    matches_pattern(title_data, self._compiled_patterns["rdp"])
                    | matches_pattern(description_data, self._compiled_patterns["rdp"])
                )
                & matches_pattern(risk_data, self._compiled_patterns["rating"])
                & ~(
                    matches_pattern(
                        solution_data, self._compiled_patterns["ignore_"]["common"])
                    | matches_pattern(solution_data, self._compiled_patterns["patch"])
                )
            },
            "telnet_condition": {
                "any": lambda: matches_pattern(
                    title_data, self.regex_word("Telnet Server")
                )
            },
            "rce_condition": {
                "any": lambda: (matches_pattern(risk_data, self._compiled_patterns["rating"]) &
                                matches_pattern(
                                    description_data, self._compiled_patterns["rce"])
                                )
                & ~(
                    matches_pattern(
                        solution_data, self._compiled_patterns["ignore_"]["common"])
                    | matches_pattern(solution_data, self._compiled_patterns["patch"])
                )
            },
            "compliance_condition": {
                "nessus": lambda: (
                    matches_pattern(
                        risk_data, self._compiled_patterns["compliance"])
                    & matches_pattern(
                        synopsis_data, self.regex_word("Compliance checks")
                    )
                ),
                "rapid": lambda: matches_pattern(
                    pci_data, self.regex_word("Fail")
                ),
            },
            "ssh_condition": {
                "nessus": lambda: matches_pattern(risk_data, self._compiled_patterns["rating"]) &
                (
                    matches_pattern(synopsis_data, self._compiled_patterns["ssh"]) |
                    matches_pattern(description_data, self._compiled_patterns["ssh"]) |
                    matches_pattern(title_data, self._compiled_patterns['ssh'])
                )
                & ~matches_pattern(solution_data, self._compiled_patterns["ignore_"]["common"]),
                "rapid": lambda: (
                    matches_pattern(
                        service_data, self._compiled_patterns["ssh"])
                    & ~matches_pattern(
                        solution_data, self._compiled_patterns["ignore_"]["common"]
                    )
                )
                | matches_pattern(title_data, self.regex_word("SSH Server")),
            },
            "information_condition": {
                "any": lambda: matches_pattern(risk_data, self._compiled_patterns["rating"]) &
                (matches_pattern(title_data, self._compiled_patterns['info']) |
                 matches_pattern(synopsis_data, self._compiled_patterns['info']))
                & ~(
                    matches_pattern(solution_data,
                                    self._compiled_patterns["software"])
                    | matches_pattern(solution_data, self._compiled_patterns["patch"])
                    | matches_pattern(title_data, self._compiled_patterns["ssl"])
                )

            },
            "database_condition": {
                "any": lambda: (
                    matches_pattern(
                        risk_data, self._compiled_patterns["rating"])
                    & matches_pattern(title_data, self.regex_word("Database"))
                    & ~matches_pattern(solution_data, self._compiled_patterns["ignore_"]["common"]
                                       )
                )
            },
            "web_condition": {
                "nessus": lambda: (
                    matches_pattern(
                        risk_data, self._compiled_patterns["rating"])
                )
                & (
                    matches_pattern(title_data, self._compiled_patterns["web"])
                    | matches_pattern(description_data, self._compiled_patterns["web"])
                    | matches_pattern(synopsis_data, self._compiled_patterns["web"])
                    | matches_pattern(solution_data, self._compiled_patterns["web"])
                )
                & ~(
                    matches_pattern(title_data, self._compiled_patterns["ssl"])
                    | matches_pattern(
                        solution_data, self._compiled_patterns["ignore_"]["common"]
                    )
                    | matches_pattern(solution_data, self._compiled_patterns["patch"])
                    | matches_pattern(synopsis_data, self._compiled_patterns["patch"])
                    | matches_pattern(description_data, self._compiled_patterns["patch"])
                    | matches_pattern(
                        title_data, self.regex_word("Information Disclosure")
                    )
                ),
                "rapid": lambda: (
                    ~(
                        matches_pattern(
                            title_data, self._compiled_patterns["ignore_"]["web"])
                        | matches_pattern(solution_data, self._compiled_patterns["software"])
                        | matches_pattern(solution_data, self._compiled_patterns["patch"])
                    )
                    & matches_pattern(service_data, self._compiled_patterns["web"])
                ),
            },
        }

        scanner = self.scanner if self.scanner in self.SCANNERS else "any"
        if filter_param in FILTERS:
            condition = FILTERS[filter_param].get(
                scanner, FILTERS[filter_param].get("any")
            )
            return {filter_param: condition()}
        else:
            return {}
