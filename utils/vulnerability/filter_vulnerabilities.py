import re


class FilterVulnerabilities:
    """Filters vulnerabilities depending on scanner used"""

    def __init__(self):
        self.scanner = None

    def update_scanner(self, scanner):
        self.scanner = scanner

    @staticmethod
    def _compile_regex(pattern):
        return re.compile(pattern)

    def filter_vulnerabilities(self, vulnerabilities, filter_param):
        """TODO: Filter vulnerabilities depending on the scanner used"""

        def matches_pattern(column, pattern):
            return vulnerabilities[column].notna() & vulnerabilities[column].str.contains(pattern, regex=True)
        # Filter Strings
        ssl_pattern = self._compile_regex(
            "SSL|TLS|POODLE|Diffie-Hellman"
        )
        patch_patterns = self._compile_regex(
            "patches|updates|security update|Microsoft has released|Update|update"
        )
        software_pattern = self._compile_regex(
            "no longer supported|unsupported|Unsupported Version|Obsolete Version|end-of-life|Upgrade|upgrade|discontinued"
        )
        reboot_strings = self._compile_regex("reboot|Reboot")

        rdp_pattern = self._compile_regex(
            "Terminal Services|Remote Desktop Protocol"
        )
        web_pattern = self._compile_regex(
            "Web|web server|HTTP|HSTS|HTTPS|IIS")

        # Reverse Filter Strings : Strings to avoid
        ssl_ignore_pattern = self._compile_regex(
            "Upgrade|Update|upgrade|update|patch"
        )
        ssh_ignore_pattern = self._compile_regex(
            "update|Update|Upgrade|upgrade"
        )
        database_ignore_pattern = self._compile_regex(
            "Update|Upgrade|update|upgrade"
        )
        web_avoid_pattern = self._compile_regex("TLS|SSL")

        match filter_param:
            case "ssl_condition":
                return (
                    {
                        "ssl_condition":  matches_pattern("Name", ssl_pattern)
                    }
                    if self.scanner == "nessus"
                    else {
                        "ssl_condition": matches_pattern("Vulnerability Title", ssl_pattern)
                        |
                        matches_pattern("Vulnerability Solution", ssl_pattern)
                        &
                        ~matches_pattern(
                            "Vulnerability Solution", ssl_ignore_pattern)

                    }
                )
            case "missing_patch_condition":

                if self.scanner == "nessus":
                    return {
                        "missing_patch_condition": matches_pattern("Solution", patch_patterns)
                    }
                elif self.scanner == "rapid":
                    return {
                        "missing_patch_condition": matches_pattern("Vulnerability Solutionn", patch_patterns)
                    }
            case "unsupported_software_condition":

                if self.scanner == "nessus":
                    return {
                        "unsupported_software_condition": matches_pattern("Solution", self.regex_word(
                            "Upgrade", second_term="Update"
                        ))
                        | matches_pattern("Name", software_pattern)
                        | matches_pattern("Description", software_pattern)
                        | matches_pattern("Solution", software_pattern)

                    }
                elif self.scanner == "rapid":
                    return {
                        "unsupported_software_condition": matches_pattern("Vulnerability Solution", self.regex_word(
                            "Upgrade", second_term="Update"
                        ))
                        |
                        matches_pattern("Vulnerability Title",
                                        software_pattern)

                    }
            case "reboot_condition":
                ignore_update_upgrade = ~(
                    matches_pattern("Solution", patch_patterns)
                    | matches_pattern("Solution", software_pattern)
                )
                reboot_match = (
                    matches_pattern("Description", reboot_strings)
                    | matches_pattern("Solution", reboot_strings)
                )
                return {
                    "reboot_condition":  ignore_update_upgrade & reboot_match
                }
            case "kaspersky_condition":
                return {
                    "kaspersky_condition": matches_pattern("Name", self.regex_word("Kaspersky"))
                }
            case "insecure_condition":
                return {
                    "insecure_condition": matches_pattern("Name", self.regex_word("Insecure Windows Service"))
                }
            case "winverify_condition":
                return {
                    "winverify_condition": matches_pattern("Name", self.regex_word("WinVerifyTrust"))
                }
            case "unquoted_condition":
                return {
                    "unquoted_condition": matches_pattern("Name", self.regex_word("Unquoted Service Path"))

                }
            case "smb_condition":
                return {
                    "smb_condition": matches_pattern("Name", self.regex_word("SMB")),
                }
            case "speculative_condition":
                return {
                    "speculative_condition":  matches_pattern("Name", self.regex_word("Windows Speculative"))
                }
            case "AD_condition":
                return {
                    "AD_condition":
                        matches_pattern("Name", self.regex_word("AD Starter"))
                }
            case "defender_condition":
                return {
                    "defender_condition": matches_pattern("Synopsis", self.regex_word("antimalware"))
                }
            case "rdp_condition":

                return {
                    "rdp_condition": matches_pattern("Name", rdp_pattern)
                }
            case "compliance_condition":
                if self.scanner == "nessus":
                    return {
                        "compliance_condition": matches_pattern("Risk", self.regex_word("FAILED"))

                        & matches_pattern("Synopsis", self.regex_word("Compliance checks"))

                    }
                elif self.scanner == "rapid":
                    return {
                        "compliance_condition":
                        matches_pattern(
                            "Vulnerability PCI Compliance Status", self.regex_word("Fail"))

                    }
            case "ssh_condition":

                return (
                    {
                        "ssh_condition": matches_pattern(
                            "Synopsis", self.regex_word("SSH server"))
                        & ~matches_pattern("Solution", ssh_ignore_pattern)

                    }
                    if self.scanner == "nessus"
                    else {
                        "ssh_condition":

                        matches_pattern(
                            "Service Name", self.regex_word("SSH"))
                        & ~matches_pattern("Vulnerability Solution", ssh_ignore_pattern)

                        |
                            matches_pattern("Vulnerability Title",
                                            self.regex_word("SSH Server"))
                    }
                )
            case "telnet_condition":
                return {
                    "telnet_condition":
                    matches_pattern("Name", self.regex_word("Telnet Server"))
                }
            case "information_condition":
                ignore_patterns = ~(matches_pattern("Solution", software_pattern)
                                    | matches_pattern("Solution", patch_patterns)
                                    )
                return {
                    "information_condition":  matches_pattern("Name", self.regex_word("Information Disclosure"))
                    & ignore_patterns

                }
            case "database_condition":

                return {
                    "database_condition": matches_pattern("Vulnerability Title", self.regex_word("Database"))
                    # ignore columns that require update or upgrade solution
                    & ~matches_pattern("Vulnerability Solution", database_ignore_pattern)
                }
            case "web_condition":
                ignore_patterns = ~(matches_pattern("Solution", software_pattern)
                                    | matches_pattern("Solution", patch_patterns)
                                    | matches_pattern("Name", web_avoid_pattern)
                                    | matches_pattern("Description", web_avoid_pattern)
                                    )
                web_accepted_patterns = (
                    matches_pattern("Name", web_pattern)
                    | matches_pattern("Description", web_pattern)
                    | matches_pattern("Solution", web_pattern)
                )
                return (
                    {
                        "web_condition": ignore_patterns & web_accepted_patterns

                    }
                    if self.scanner == "nessus"
                    else {

                        "web_condition": matches_pattern("Service Name", web_pattern)

                        & ~(matches_pattern("Vulnerability Title", web_avoid_pattern)
                            | matches_pattern("Vulnerability Solution", software_pattern)
                            | matches_pattern("Vulnerability Solution", patch_patterns))

                    }
                )
            case "rce_condition":
                return {
                    "rce_condition": matches_pattern("Description", self.regex_word("remote code execution"))
                }
            case _:
                pass

    @staticmethod
    def loop_through_files(
        file_list: list,
        start_file,
        read_csv: callable,  # reference a callable function
        original_datafile,
        error_text: str,
        get_missing_columns: callable,
        concat_dataframes: callable,
        read_xlsx: callable,
        get_file_extension: callable,
    ):
        """
        Process multiple files and combine their data

        Args:
            file_list: List of files to process
            start_file: Initial file path
            read_csv: Function to read CSV files
            original_datafile: Initial dataframe to compare against
            error_text: Error message for column mismatch
            get_missing_columns: Function to check missing columns
            concat_dataframes: Function to combine dataframes
            read_xlsx: Function to read Excel files
            get_file_extension: Function to get file extension
        """
        all_vulnerabilities = original_datafile
        for file in file_list:
            full_file_path = file["full_path"]

            if full_file_path != start_file:
                try:

                    file_extension = get_file_extension(full_file_path)

                    # Use relevant pandas method depending on file
                    if file_extension.lower() in ["xlsx", "xls"]:
                        new_data = read_xlsx(full_file_path, header=None)
                    elif file_extension.lower() == "csv":
                        new_data = read_csv(full_file_path, header=None)
                    else:
                        raise ValueError(
                            f"Unsupported file extension: {file_extension}"
                        )
                        continue
                    # Check if new data is empty
                    if new_data.empty:
                        print(f"Skipping empty file : {file['filename']}")
                        continue

                    # Ensure columns match
                    if original_datafile.shape[1] != new_data.shape[1]:
                        print(
                            f"New file {file['filename']} has "
                            f"{len(new_data.columns)} columns "
                        )
                        raise ValueError(error_text)

                    # Check if other files have missing columns
                    get_missing_columns(new_data, file["filename"])
                    # Append new data to the original data
                    all_vulnerabilities = concat_dataframes(
                        all_vulnerabilities, new_data
                    )
                except Exception as e:
                    print(f"Error processing file {file['filename']}: {e}")
                    continue

        return all_vulnerabilities

    @staticmethod
    def percentage_null_fields(dataframe):
        # determine percentage accuracy of the data by showing null fields
        for i in dataframe.columns:
            null_rate = dataframe[i].isna().sum() / len(dataframe) * 100
            if null_rate > 0:
                print(f"{i} null rate: {null_rate:.2f}%")

    @staticmethod
    def csv_filter_operations(dataframe, filter_option, operation, **kwargs):
        # Function to combine all the major CSV filters into one for code clarity
        match operation:
            case "notnull":
                return dataframe[filter_option].notna()
            case "contains":
                if "contains_key" in kwargs:
                    # check for any key value pair passed as an  extra argument and uses it as a filter
                    return dataframe[filter_option].str.contains(kwargs["contains_key"])
            case "in":
                if "in_key" in kwargs:
                    return dataframe[filter_option].isin(kwargs["in_key"])
            case _:
                raise ValueError(f"Invalid filter option: {filter_option}")

    @staticmethod
    def regex_word(search_term: str, **kwargs):
        """Performs a regex check against a given term
        :param  search_term: string containg the characters to search for
        :param  kwargs: 
                second_term: second value to search against
                checks for text that has the first term but not the second

        :returns text
        """
        if kwargs.get("second_term"):
            return rf'\b{search_term}\b(?!.*\b{kwargs["second_term"]}\b)'
        return rf"\b{search_term}\b"
