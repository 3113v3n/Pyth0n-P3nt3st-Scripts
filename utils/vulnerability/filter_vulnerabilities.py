import re


class FilterVulnerabilities:
    """Filters vulnerabilities depending on scanner used"""

    def __init__(self):
        self.scanner = None

    def update_scanner(self, scanner):
        self.scanner = scanner

    @staticmethod
    def _compile_regex(pattern):
        return re.compile(pattern)

    def filter_vulnerabilities(self, vulnerabilities, filter_param):
        """TODO: Filter vulnerabilities depending on the scanner used"""

        match filter_param:
            case "ssl_condition":
                if self.scanner == "nessus":
                    ssl_pattern = self._compile_regex("SSL|TLS|POODLE")
                    return {
                        "ssl_condition": (vulnerabilities["Name"].notna())
                                         & (
                                             vulnerabilities["Name"].str.contains(
                                                 ssl_pattern, regex=True
                                             )
                                         )
                    }
                elif self.scanner == "rapid":
                    ssl_pattern = self._compile_regex("SSL|TLS")
                    return {
                        "ssl_condition": (vulnerabilities["Vulnerability Title"].notna())
                                         & (
                                             vulnerabilities["Vulnerability Title"].str.contains(
                                                 ssl_pattern, regex=True
                                             )
                                         )

                    }
            case "missing_patch_condition":
                patch_patterns = self._compile_regex(
                    "patches|updates|security update|Microsoft has released|Update")
                if self.scanner == "nessus":
                    return {
                        "missing_patch_condition": (vulnerabilities["Solution"].notna())
                                                   & (vulnerabilities["Solution"].str.contains(patch_patterns))

                    }
                elif self.scanner == "rapid":
                    return {
                        "missing_patch_condition": (vulnerabilities["Vulnerability Solution"].notna())
                                                   & (vulnerabilities["Vulnerability Solution"].str.contains(
                            patch_patterns))

                    }
            case "unsupported_software":
                software_pattern = self._compile_regex(
                    "no longer supported|unsupported|Unsupported Version|Obsolete Version|end-of-life|Upgrade")
                if self.scanner == "nessus":
                    return {
                        "unsupported_software": (vulnerabilities["Solution"].notna())
                                                & (
                                                    vulnerabilities["Solution"].str.contains(
                                                        self.regex_word("Upgrade", is_extra=True,
                                                                        second_term="Update"),
                                                        regex=True,
                                                    )
                                                )
                                                | (
                                                    vulnerabilities["Name"].str.contains(
                                                        software_pattern, regex=True
                                                    )
                                                )
                                                | (
                                                    vulnerabilities["Description"].str.contains(
                                                        software_pattern, regex=True
                                                    )
                                                )

                                                | (
                                                    vulnerabilities["Solution"].str.contains(
                                                        software_pattern, regex=True
                                                    )
                                                )

                    }
                elif self.scanner == "rapid":
                    return {
                        "unsupported_software": (vulnerabilities["Vulnerability Solution"].notna())
                                                & (
                                                    vulnerabilities["Vulnerability Solution"].str.contains(
                                                        self.regex_word("Upgrade", is_extra=True,
                                                                        second_term="Update"),
                                                        regex=True,
                                                    )
                                                )
                                                | (
                                                    vulnerabilities["Vulnerability Title"].str.contains(
                                                        software_pattern, regex=True
                                                    )
                                                )

                    }
            case "kaspersky_condition":
                return {
                    "kaspersky_condition": (vulnerabilities["Name"].notna())
                                           & vulnerabilities["Name"].str.contains(
                        self.regex_word("Kaspersky"), regex=True
                    ),
                }
            case "insecure_condition":
                return {
                    "insecure_condition": (vulnerabilities["Name"].notna())
                                          & vulnerabilities["Name"].str.contains(
                        self.regex_word("Insecure Windows Service"), regex=True
                    ),
                }
            case "winverify_condition":
                return {
                    "winverify_condition": (vulnerabilities["Name"].notna())
                                           & vulnerabilities["Name"].str.contains(
                        self.regex_word("WinVerifyTrust"), regex=True
                    ),
                }
            case "unquoted_condition":
                return {
                    "unquoted_condition": (vulnerabilities["Name"].notna())
                                          & vulnerabilities["Name"].str.contains(
                        self.regex_word("Unquoted Service Path"), regex=True
                    ),
                }
            case "smb_condition":
                return {
                    "smb_condition": (vulnerabilities["Name"].notna())
                                     & vulnerabilities["Name"].str.contains(
                        self.regex_word("SMB"), regex=True
                    ),
                }
            case "speculative_condition":
                return {
                    "speculative_condition": (vulnerabilities["Name"].notna())
                                             & vulnerabilities["Name"].str.contains(
                        self.regex_word("Windows Speculative"), regex=True
                    ),
                }
            case "AD_condition":
                return {
                    "AD_condition": (vulnerabilities["Name"].notna())
                                    & vulnerabilities["Name"].str.contains(
                        self.regex_word("AD Starter"), regex=True
                    ),
                }
            case "defender_condition":
                return {
                    "defender_condition": (vulnerabilities["Synopsis"].notna())
                                          & vulnerabilities["Synopsis"].str.contains(
                        self.regex_word("antimalware"), regex=True
                    ),
                }
            case "rdp_condition":
                rdp_pattern = self._compile_regex(
                    "Terminal Services|Remote Desktop Protocol")
                return {
                    "rdp_condition": (vulnerabilities["Name"].notna())
                                     & (
                                         vulnerabilities["Name"].str.contains(
                                             rdp_pattern, regex=True
                                         )
                                     )

                }
            case "compliance_condition":
                if self.scanner == "nessus":
                    return {
                        "compliance_condition": (vulnerabilities["Risk"].notna())
                                                & (
                                                    vulnerabilities["Risk"].str.contains(
                                                        self.regex_word("FAILED"), regex=True
                                                    )
                                                )
                                                & (
                                                    vulnerabilities["Synopsis"].str.contains(
                                                        self.regex_word("Compliance checks"), regex=True
                                                    )
                                                ),
                    }
                elif self.scanner == "rapid":
                    return {
                        "compliance_condition": (vulnerabilities["Vulnerability PCI Compliance Status"].notna())
                                                & (
                                                    vulnerabilities["Vulnerability PCI Compliance Status"].str.contains(
                                                        self.regex_word("Fail"), regex=True
                                                    )
                                                )

                    }
            case "ssh_condition":
                if self.scanner == "nessus":
                    return {
                        "ssh_condition": (vulnerabilities["Synopsis"].notna())
                                         & vulnerabilities["Synopsis"].str.contains(
                            self.regex_word("SSH server"), regex=True
                        ),
                    }
                elif self.scanner == "rapid":
                    return {
                        "ssh_condition": (vulnerabilities["Service Name"].notna())
                                         & vulnerabilities["Service Name"].str.contains(
                            self.regex_word("SSH"), regex=True
                        ) | (vulnerabilities["Vulnerability Title"].str.contains(
                            self.regex_word("SSH Server"), regex=True
                        )),
                    }
            case "telnet_condition":
                return {
                    "telnet_condition": (vulnerabilities["Name"].notna())
                                        & vulnerabilities["Name"].str.contains(
                        self.regex_word("Telnet Server"), regex=True
                    ),
                }
            case "information_condition":
                return {
                    "information_condition": (vulnerabilities["Name"].notna())
                                             & vulnerabilities["Name"].str.contains(
                        self.regex_word("Information Disclosure"), regex=True
                    ),
                }
            case "web_condition":
                web_pattern = self._compile_regex("Web|web server|HTTP|HTTPS")
                avoid_pattern = self._compile_regex("TLS|SSL")
                if self.scanner == "nessus":
                    return {
                        "web_condition": (vulnerabilities["Name"].notna())
                                         & (
                                             vulnerabilities["Name"].str.contains(
                                                 web_pattern, regex=True
                                             )
                                         )
                                         | (
                                             vulnerabilities["Description"].str.contains(
                                                 web_pattern, regex=True
                                             )
                                         ),
                    }
                elif self.scanner == "rapid":
                    return {
                        "web_condition": (vulnerabilities["Service Name"].notna())
                                         & (
                                             vulnerabilities["Service Name"].str.contains(
                                                 web_pattern, regex=True
                                             )
                                         ) & (
                                             ~vulnerabilities["Vulnerability Title"].str.contains(
                                                 avoid_pattern,
                                                 regex=True,
                                             )
                                         )
                    }
            case "rce_condition":
                return {
                    "rce_condition": (vulnerabilities["Description"].notna())
                                     & (
                                         vulnerabilities["Description"].str.contains(
                                             self.regex_word("remote code execution"), regex=True
                                         )
                                     ),
                }
            case _:
                pass

    @staticmethod
    def loop_through_files(file_list: list,
                           start_file,
                           read_csv: callable,  # reference a callable function
                           original_datafile,
                           error_text: str,
                           get_missing_columns: callable,
                           concat_dataframes: callable,
                           read_xlsx: callable,
                           get_file_extension: callable):
        """
        Process multiple files and combine their data
        
        Args:
            file_list: List of files to process
            start_file: Initial file path
            read_csv: Function to read CSV files
            original_datafile: Initial dataframe to compare against
            error_text: Error message for column mismatch
            get_missing_columns: Function to check missing columns
            concat_dataframes: Function to combine dataframes
            read_xlsx: Function to read Excel files
            get_file_extension: Function to get file extension
        """
        all_vulnerabilities = original_datafile
        for file in file_list:
            full_file_path = file["full_path"]

            if full_file_path != start_file:
                try:

                    file_extension = get_file_extension(full_file_path)
                    
                    # Use relevant pandas method depending on file
                    if file_extension.lower() in ["xlsx", "xls"]:
                        new_data = read_xlsx(full_file_path, header=None)
                    elif file_extension.lower() == "csv":
                        new_data = read_csv(full_file_path, header=None)
                    else:
                        raise ValueError(f"Unsupported file extension: {file_extension}")
                        continue
                    # Check if new data is empty
                    if new_data.empty:
                        print(f"Skipping empty file : {file['filename']}")
                        continue

                    # Ensure columns match
                    if original_datafile.shape[1] != new_data.shape[1]:
                        print(
                            f"New file {file['filename']} has "
                            f"{len(new_data.columns)} columns "
                        )
                        raise ValueError(error_text)

                    # Check if other files have missing columns
                    get_missing_columns(new_data, file["filename"])
                    # Append new data to the original data
                    all_vulnerabilities = concat_dataframes(
                        all_vulnerabilities, new_data
                    )
                except Exception as e:
                    print(f"Error processing file {file['filename']}: {e}")
                    continue
                
        return all_vulnerabilities

    @staticmethod
    def percentage_null_fields(dataframe):
        # determine percentage accuracy of the data by showing null fields
        for i in dataframe.columns:
            null_rate = dataframe[i].isna().sum() / len(dataframe) * 100
            if null_rate > 0:
                print(f"{i} null rate: {null_rate:.2f}%")

    @staticmethod
    def csv_filter_operations(dataframe, filter_option, operation, **kwargs):
        # Function to combine all the major CSV filters into one for code clarity
        match operation:
            case "notnull":
                return dataframe[filter_option].notna()
            case "contains":
                if "contains_key" in kwargs:
                    # check for any key value pair passed as an  extra argument and uses it as a filter
                    return dataframe[filter_option].str.contains(kwargs["contains_key"])
            case "in":
                if "in_key" in kwargs:
                    return dataframe[filter_option].isin(kwargs["in_key"])
            case _:
                raise ValueError(f"Invalid filter option: {filter_option}")

    @staticmethod
    def regex_word(search_term, **kwargs):
        if "is_extra" in kwargs:
            return rf'\b{search_term}\b(?!.*\b{kwargs["second_term"]}\b)'
        return rf"\b{search_term}\b"
